validateSLAInput() {
    // Reset validation errors
    this.formValidationErrors = {
        nearSLA: [],
        breachSLA: [],
    };

    // Validate Near SLA and Breach SLA
    this.validateField('nearSLA', this.nearSLA);
    this.validateField('breachSLA', this.BreachSLA);

    // Check for specific error messages
    const nearSLAErrors = this.formValidationErrors.nearSLA || [];
    const breachSLAErrors = this.formValidationErrors.breachSLA || [];

    const hasBlockingErrors = nearSLAErrors.includes(
        'Nearing SLA Cannot be greater than Breached SLA'
    ) || breachSLAErrors.includes(
        'Breached SLA Cannot be less than Nearing SLA'
    );

    // Return false if there are blocking errors
    return !hasBlockingErrors;
}

validateField(field, value) {
    this.formValidationErrors[field] = []; // Reset errors for the field

    switch (field) {
        case 'nearSLA':
            this.validateRequired('nearSLA', value);
            this.validateNearSLABreachSLA(field, this.nearSLA, this.BreachSLA);
            break;
        case 'breachSLA':
            this.validateRequired('breachSLA', value);
            this.validateNearSLABreachSLA(field, this.nearSLA, this.BreachSLA);
            break;
        default:
            break;
    }

    this.formValidationErrors = { ...this.formValidationErrors }; // Trigger UI update
}

validateRequired(field, value) {
    if (!value) {
        this.formValidationErrors[field].push(`Cannot be Zero`);
    } else if (value === 0) {
        this.formValidationErrors[field].push(`Cannot be Zero`);
    }
}

validateNearSLABreachSLA(field, nearsla, breachsla) {
    if (nearsla > breachsla) {
        if (field === 'nearSLA') {
            this.formValidationErrors[field].push(
                'Nearing SLA Cannot be greater than Breached SLA'
            );
        } else if (field === 'breachSLA') {
            this.formValidationErrors[field].push(
                'Breached SLA Cannot be less than Nearing SLA'
            );
        }
    }
}

async handleSubmit() {
    try {
        // Validate required fields and SLA inputs
        const requiredFieldsValid = validateRequiredField(this.shadowRoot);
        const slaValid = this.validateSLAInput();

        // If validation fails, display errors and block submission
        if (!requiredFieldsValid || !slaValid) {
            console.warn('Form submission blocked due to validation errors:', this.formValidationErrors);
            return;
        }

        // Continue with form submission
        this.isLoading = true;

        // Build request payload
        const valuesArray = [];
        const rowValues = {
            insName: this.workbasketLabel,
            pyLabel: this.selectedWBdropdown || this.uniqueWorkbasket,
            workBasketName: this.uniqueWorkbasket,
            wbName: this.selectedWBdropdown || this.uniqueWorkbasket,
            nearingSlaTime: this.nearSLA,
            breachedSlaTime: this.BreachSLA,
            applicationName: this.businessFunction,
            createdBy: this.userPSID,
            makerName: this.userOpName,
            makerComments: this.comments,
            active: !this.deleteCheck ? 'Y' : 'N',
            id: +this.id,
        };
        valuesArray.push(rowValues);

        const query = addUpdateQueueRequest(
            valuesArray
                .map(item => {
                    const keyValuePairs = Object.entries(item)
                        .map(([key, value]) => {
                            if (['nearingSlaTime', 'breachedSlaTime', 'id'].includes(key)) {
                                return `${key}:${value}`;
                            } else {
                                return `${key}:"${value}"`;
                            }
                        })
                        .join(',');
                    return `{${keyValuePairs}}`;
                })
                .join(',')
        );

        // Submit request
        const response = await this.graphQLClientService.query(query);
        const result = await getCommomTransformer(
            response,
            'post_addUpdateQueueRequest'
        );

        if (result != null) {
            const event = new CustomEvent('sb-add-update-record-result', {
                detail: {
                    open: false,
                    data: result,
                    message: 'REQUEST HAS BEEN SUCCESSFULLY UPDATED',
                },
            });
            this.dispatchEvent(event);
            this.isLoading = false;
            this.closeModal();
        }
    } catch (error) {
        console.error('Error loading page data:', error);
    }
}
